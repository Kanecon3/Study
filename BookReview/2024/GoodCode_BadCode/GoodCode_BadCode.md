date:2024年8月  

書籍『Good Code, Bad Code ～持続可能な開発のためのソフトウェアエンジニア的思考』  
https://www.amazon.co.jp/dp/B0BSW72QKZ/  

注：分かりづらい箇所の項目や内容は若干変更しています。  

---

＜目次＞  

- [書籍の概要](#書籍の概要)
- [理論編](#理論編)
  - [コードの品質](#コードの品質)
    - [コードの品質のゴール](#コードの品質のゴール)
      - [正しく動くこと](#正しく動くこと)
      - [正しく動作し続けること](#正しく動作し続けること)
      - [要件の変更に対応しやすいこと](#要件の変更に対応しやすいこと)
      - [車輪の再発明をしないこと](#車輪の再発明をしないこと)
    - [コードの品質の柱](#コードの品質の柱)
    - [高品質なコードを書くことは開発のスピードを遅らせるのか](#高品質なコードを書くことは開発のスピードを遅らせるのか)
    - [まとめ](#まとめ)
  - [抽象化レイヤー](#抽象化レイヤー)
    - [コードのレイヤー](#コードのレイヤー)
      - [APIと実装の詳細](#apiと実装の詳細)
      - [関数](#関数)
      - [クラス](#クラス)
      - [インターフェイス](#インターフェイス)
    - [まとめ](#まとめ-1)
  - [コードでの契約](#コードでの契約)
    - [あなたのコードと他のエンジニアのコード](#あなたのコードと他のエンジニアのコード)
    - [コードでの契約](#コードでの契約-1)
      - [契約の中の細則](#契約の中の細則)
      - [細かいコメントに頼りすぎない](#細かいコメントに頼りすぎない)
    - [検査とアサーション](#検査とアサーション)
      - [検査](#検査)
      - [アサーション](#アサーション)
    - [まとめ](#まとめ-2)
  - [エラー](#エラー)
    - [回復可能性](#回復可能性)
      - [回復可能なエラー](#回復可能なエラー)
      - [回復不可能なエラー](#回復不可能なエラー)
    - [堅牢性 vs 失敗](#堅牢性-vs-失敗)
      - [早い失敗](#早い失敗)
      - [目立つ失敗](#目立つ失敗)
      - [回復可能かどうかの範囲](#回復可能かどうかの範囲)
      - [エラーを隠さない](#エラーを隠さない)
    - [エラーを通知する方法](#エラーを通知する方法)
      - [例外](#例外)
      - [明示的：検査例外](#明示的検査例外)
      - [暗黙的：非検査例外](#暗黙的非検査例外)
      - [明示的：null許容型の戻り値](#明示的null許容型の戻り値)
      - [明示的：Result型の戻り値](#明示的result型の戻り値)
      - [明示的：エラーを示す戻り値](#明示的エラーを示す戻り値)
      - [暗黙的：Promise型かFuture型](#暗黙的promise型かfuture型)
    - [まとめ](#まとめ-3)
- [実践編](#実践編)
  - [コードを読みやすくする](#コードを読みやすくする)
    - [わかりやすい名前を使う](#わかりやすい名前を使う)
    - [コメントを適切に使う](#コメントを適切に使う)
    - [コードの行数にこだわらない](#コードの行数にこだわらない)
    - [一貫したコーディングスタイルにこだわる](#一貫したコーディングスタイルにこだわる)
    - [ネストの深いコードは避ける](#ネストの深いコードは避ける)
    - [関数の呼び出しを読みやすくする](#関数の呼び出しを読みやすくする)
    - [説明のない値を使用しない](#説明のない値を使用しない)
    - [無名関数を適切に使用する](#無名関数を適切に使用する)
    - [すばらしい新しい言語機能を適切に使用する](#すばらしい新しい言語機能を適切に使用する)
    - [まとめ](#まとめ-4)
  - [想定外の事態をなくす](#想定外の事態をなくす)
    - [マジックナンバー(直値)を戻り値に使わない](#マジックナンバー直値を戻り値に使わない)
    - [nullオブジェクトパターンを使用することが本当に適切なのか考える](#nullオブジェクトパターンを使用することが本当に適切なのか考える)
    - [予期せぬ副作用の発生を避ける](#予期せぬ副作用の発生を避ける)
    - [引数の変更に注意する](#引数の変更に注意する)
    - [誤解を招くような関数の書き方を避ける](#誤解を招くような関数の書き方を避ける)
      - [重要な入力値が欠けているときに何もしないと、想定外の事態を起こす可能性がある](#重要な入力値が欠けているときに何もしないと想定外の事態を起こす可能性がある)
    - [将来的にも有効に使い続けられるように設計された列挙型処理](#将来的にも有効に使い続けられるように設計された列挙型処理)
      - [将来の列挙型を暗黙的に処理すると、問題が発生する可能性がある](#将来の列挙型を暗黙的に処理すると問題が発生する可能性がある)
      - [デフォルトケースに注意する](#デフォルトケースに注意する)
    - [これらのすべてをテストで解決することはできないか？](#これらのすべてをテストで解決することはできないか)
    - [まとめ](#まとめ-5)
  - [誤用しにくいコードを書く](#誤用しにくいコードを書く)
    - [誤用しにくい](#誤用しにくい)
    - [すべてを不変にすることを検討する](#すべてを不変にすることを検討する)
      - [可変クラスは誤用されやすい](#可変クラスは誤用されやすい)
    - [すべてを深く不変にすることを検討する](#すべてを深く不変にすることを検討する)
    - [あまりにも汎用的なデータ型を避ける](#あまりにも汎用的なデータ型を避ける)
    - [時間の扱い](#時間の扱い)
    - [データに対して信頼できる唯一の情報源を持つ](#データに対して信頼できる唯一の情報源を持つ)
    - [まとめ](#まとめ-6)
  - [コードをモジュール化する](#コードをモジュール化する)
    - [DIを使用する](#diを使用する)
      - [ハードコーディングされた依存関係](#ハードコーディングされた依存関係)
      - [DIを念頭に置いてコードを設計する](#diを念頭に置いてコードを設計する)
    - [インターフェイスに依存する](#インターフェイスに依存する)
    - [クラスの継承に注意](#クラスの継承に注意)
      - [ミックスイン(Mixin)とトレイト(trait)](#ミックスインmixinとトレイトtrait)
    - [クラスは自分自身に関心を持つべき](#クラスは自分自身に関心を持つべき)
      - [デメテルの法則](#デメテルの法則)
    - [関連データをまとめてカプセル化する](#関連データをまとめてカプセル化する)
      - [カプセル化していないデータは扱いにくい](#カプセル化していないデータは扱いにくい)
    - [戻りの型から実装の詳細が漏洩することに注意する](#戻りの型から実装の詳細が漏洩することに注意する)
    - [例外の中から実装の詳細が漏洩することに注意する](#例外の中から実装の詳細が漏洩することに注意する)
    - [まとめ](#まとめ-7)
  - [コードを再利用、汎用化しやすくする](#コードを再利用汎用化しやすくする)
    - [グローバル状態に注意する](#グローバル状態に注意する)
    - [デフォルト値を適切に使用する](#デフォルト値を適切に使用する)
    - [ジェネリクスの使用を検討する](#ジェネリクスの使用を検討する)
    - [まとめ](#まとめ-8)
- [ユニットテスト編](#ユニットテスト編)
  - [ユニットテストの原則](#ユニットテストの原則)
  - [よいユニットテストとは？](#よいユニットテストとは)
    - [破損を正確に検出する](#破損を正確に検出する)
    - [実装の詳細にとらわれない](#実装の詳細にとらわれない)
      - [機能変更とリファクタリングを混在しない](#機能変更とリファクタリングを混在しない)
    - [よく説明された失敗](#よく説明された失敗)
    - [わかりやすいテストコード](#わかりやすいテストコード)
    - [簡単かつ迅速に実行する](#簡単かつ迅速に実行する)
  - [パブリックAPIに注目しても重要な動作は無視しない](#パブリックapiに注目しても重要な動作は無視しない)
  - [テストダブル](#テストダブル)
    - [テストダブルを使用する理由](#テストダブルを使用する理由)
      - [モック](#モック)
      - [スタブ](#スタブ)
      - [フェイク](#フェイク)
    - [まとめ](#まとめ-9)
  - [ユニットテストの実践](#ユニットテストの実践)
    - [ただ関数をテストするのではなく動作をテストする](#ただ関数をテストするのではなく動作をテストする)
    - [テストのためだけに公開するのは避ける](#テストのためだけに公開するのは避ける)
      - [パラメタライズドテスト](#パラメタライズドテスト)
    - [共通のテストのセットアップを適切に使う](#共通のテストのセットアップを適切に使う)
      - [状態の共有は問題になる可能性がある](#状態の共有は問題になる可能性がある)
  - [適切なアサーションマッチャーを使う](#適切なアサーションマッチャーを使う)
  - [DIを使っててスタビリティを補強する](#diを使っててスタビリティを補強する)
  - [テストについての最後の言葉](#テストについての最後の言葉)
    - [まとめ](#まとめ-10)
- [null安全とオプショナル](#null安全とオプショナル)
  - [null安全の使用](#null安全の使用)
  - [オプショナルの使用](#オプショナルの使用)
- [訳者あとがき](#訳者あとがき)
  - [おさらい](#おさらい)
  - [それらを実践する中で、気を付けるべきこと](#それらを実践する中で気を付けるべきこと)
  - [テストについて学んだこと](#テストについて学んだこと)
  - [最後に](#最後に)

---

# 書籍の概要

この書籍は、よいコードと悪いコードを比較することで、コードの善し悪しを判断するための概念やテクニックを紹介しています。  
GoogleのテックリードであるTom Long氏の知識と経験に基づいています。  

# 理論編

この「理論編」の目的は、**コードを書くことの理論的な側面について、しっかりとした基礎知識を提供すること** です。

ソフトウェアエンジニアリングは精密な科学ではないので、絶対といえるルールを生み出すことはできません。すべてのプロジェクトはそれぞれ異なり、ほとんどの場合は考慮すべきトレードオフがつきものです。よいコードを書くためには、目の前のシナリオに対して健全な判断力を持ち、何かを行うための特定の方法の結果(よい面と悪い面)を熟考しなければなりません。  

## コードの品質

高品質なコードは、信頼度が高く、メンテナンスしやすく、ほとんどバグがないソフトウェアを生み出します。  

よいコードは、よいソフトウェアを作るための唯一の要素ではありませんが、ソフトウェアを形作るための重要な要素の1つです。  

### コードの品質のゴール

コード品質のゴールは次のとおりです。

1. 正しく動くこと
2. 正しく動作し続けること
3. 要件の変更に対応しやすいこと
4. 車輪の再発明をしないこと

#### 正しく動くこと

コードが「正しく動く」という定義は、すべての要件を満たしているということです。  

#### 正しく動作し続けること

コードが動作し続けることを担保するのは、エンジニアが直面する最大限に考慮すべきことであり、コーディング中は常に考慮すべきです。後で考慮すればいい、もしくは後でテストを付け加えればいいと考えるのは、たいていの場合、効果的なアプローチではありません。

#### 要件の変更に対応しやすいこと

一度書かれたコードが、その後いっさいの変更がないということは、まずありません。今後、コードやソフトウェアがどのように変わっていくかを完璧には予測できません。とはいえ、予測できないからといって、変化していくだろうという実情を完全に無視すべきということではありません。  

#### 車輪の再発明をしないこと

他のエンジニアが問題を解決すべきコードをすでに書いているなら、同じようなものを書くよりも、そのコードを利用すべきでしょう。一方で、問題を解決するコードを書いたのであれば、必要としている他のエンジニアが使いやすいようにして、車輪の再発明を防ぎます。

### コードの品質の柱

コード品質の6つの柱は次のとおりです。

1. コードを読みやすくする
2. 想定外の事態をなくす
3. 誤用しにくいコードを書く
4. コードをモジュール化する
5. コードを再利用、汎用化しやすくする
6. テストしやすいコードを書き、適切にテストする

### 高品質なコードを書くことは開発のスピードを遅らせるのか

品質を考えず、まず頭に思い浮かぶコードを書くと、最初は時間の節約になるかもしれません。  
しかし、壊れやすく複雑なコードベースがすぐにでき上り、次第にコードの理解や意味の推測が難しくなります。新しく機能を追加したりバグを直したりするのをさらに難しく、かつ遅くします。あせりと速さを間違えないでください。  

### まとめ

- よいソフトウェアを作るためには、高品質なコードを書かなければならない
- ソフトウェアが世に出るまでに、さまざまなチェックとテストの段階を通過しなければならない(手動または自動)
- これらのチェックは、バグを含んだ壊れた機能がユーザーに届くことや、ビジネス上の重大な問題を防ぐ
- 毎回のコーディング段階でテストのことを考慮するとよい。コーディング後だけに考慮するべきことではない
- 高品質なコードを書くことは、最初は開発の速度を落とすように見える。しかし、多くの場合、中長期的には開発の速度を上げる

## 抽象化レイヤー

どのようにコードを構造化するかは、コード品質における最も基本的な側面です。そして、うまく構造化できれば、きれいな **抽象化レイヤー** につながります。

### コードのレイヤー

実際には、抽象化レイヤーを作ることはコードを異なる単位に分割することです。多くのプログラミング言語には、コードをさまざまな単位に分割するための構成概念があります。多くの場合、次に挙げるようなものです。  

- 関数
- クラス、構造体
- インターフェイス
- パッケージ、名前空間、モジュール

#### APIと実装の詳細

コードを書くときは、次の2つの側面について考える必要があります。  

1. 呼び出し元から見えるもの  
   - どのクラス・関数・インターフェイスが公開されているか
   - 呼び出し元がコードを利用する際に、知るべき情報(呼び出す順番など)
2. 呼び出し元からは見えないもの。実装の詳細

#### 関数

関数を小さくして焦点を絞ることは、コードの読みやすさと再利用性を担保する、最高の方法の1つです。  
長くて読みづらい関数を作るのは簡単ですが、コードを書きあげてレビューに出す前に、コードを自分で批判的に見ることが重要です。

#### クラス

以下の考え方が、エンジニアを高品質なコードを書くべき方向へ導きます。

- 1つのクラスは1つのことに関心を持つべき
- 1つのクラスは凝集すべき

多くのことをやりすぎている巨大なクラスは、コードの品質を落としています。

#### インターフェイス

既存の抽象化レイヤーに対して2つ以上の実装が存在したり、これからも別の実装が増えていくと考えられる場合、インターフェイスを定義するとよいでしょう。  
1つ1つのクラスをすべてインターフェイスで隠蔽するという極端なスタンスを取ると、手に負えなくなります。多くのメリットが得られる場合のみにインターフェイスを利用します。インターフェイスを利用すること自体を目的にしないことです。

### まとめ

- コードをきれいで明確な抽象化レイヤーに分割することで、コードはもっと読みやすく、モジュール性や再利用性も高く、汎用的で、テストしやすくなる
- コードを抽象化レイヤーに分ける際、関数、クラス、インターフェイスを利用できる
- どのようにコードを抽象化レイヤーに分割するかを決定するには、自分自身の判断と、解決しようとしている問題に関する知識の活用が必要になる

## コードでの契約

この章では、他のエンジニアにコードの重要事項を伝えるためのさまざまなテクニックについて紹介しています。このテクニックは、コードでの契約と細かいコメントの概念によって形作られます。

### あなたのコードと他のエンジニアのコード

高品質なコードを書くための主な検討事項の1つは、他のエンジニアがどのようにコードを壊したり誤用したりするかを考え、それらが起こる可能性を最小限にするように先手を打って回避することです。

### コードでの契約

**契約プログラミング(あるいは、契約による設計)** という用語を耳にしたことがあるでしょう。他のエンジニアにコードの使い方やどういう挙動が期待できるかを伝える方法に関するいくつかの概念を形式化した原則です。エンジニアはコード間で契約を結んでいるかのように考えます。呼び出し元は特定の義務を果たす必要があり、対価として呼び出したコードは目的の値を返したり、いくつかの状態を変更します。  

コードの契約の中で、エンジニアがいつくかの契約を見落としていた場合、問題が発生します。どうしたらあなたのコードを使う人たちが確実に契約を認識し、それに沿った行動をするかを考えることが重要です。  

#### 契約の中の細則

実世界において、契約には、明確なものと、細則の中に埋もれて不明瞭なものがあります。契約の中にある細則はすべて読むべきだとわかってはいますが、ほとんどの人は細則を実際は読みません。
コードでの契約を定義する際、実世界の契約と同様に明確なものと不明確なものがあります。  

- 明確なもの
  - 関数とクラスの名前
  - パラメータの型
  - 戻り値の型
- 不明瞭なもの
  - コメントとドキュメント：実世界の契約書の細則と同じように、本来は完璧に読むべきだが、実際は読まないことが多いでしょう。エンジニアは、この事実に目を向けなければなりません
  - 非検査例外：例外がコメントに載っている場合、それは契約書の細則のようなものです。数階層下のレイヤーで例外をスローした際に、これよりも上の階層のレイヤーで関数を作ったエンジニアがドキュメントに書き忘れていたら、そもそも細則の問題にすらならないことがあります

#### 細かいコメントに頼りすぎない

細則のような細かいコメントやドキュメントは、見落としやすいものです。つまり、細かいコメントを書くことは、コードでの契約を伝えるために信頼できる方法ではないということです。高品質なコードの敵です。  

細かいコメントに頼りすぎているクラスの例：  
```
class UserSettings {
  // Init()は他の関数より先に呼ばなければならない
  // ただし、先にLoadSettings()を呼び出して設定を読み込むこと
  void init() {}

  // この関数を使って設定が正しく読み込まれるまで、他の関数を呼ばないこと
  Boolean loadSettings() {}

  // ユーザーが選択したUIの色を返す
  // 設定を読み込んでいない、あるいは初期化していない場合はnullを返す
  UiColor getUiColor() {}
}
```

コメントに頼り切ったこのUserSettingsを、呼び出し元を作成するエンジニアが使った場合に、これらの関数が順番に呼び出されない可能性があります。これは最悪な契約です。細かいコメントを読まずにこのクラスを使っていたら、セットアップが正しく行われない可能性が非常に高くなります。呼び出し元では潜在的なバグが潜むことになります。  

```
userSettings = UserSettings();

UiColor color = userSettings.getUiColor();
if (color == null) {
  ui.setColor(DEFAULT_UI_COLOR);
  return;
}
ui.setColor(color);
```
この例では、userSettingが正しくセットアップされていなかったとしても、プログラムはクラッシュせずに、何となく正しそうな動作をします。しかし、ユーザーが選択したUIの色を無視するというバグが明らかにあります。  

コードを正しく利用するためには細かいコメントに頼らなければならないといった状況を作るのではなく、間違ったことをできなくする方が良いわけです。入力値や戻り値のデータ型を注意深く考えることで、細かいコメントからコードでの契約の一部へ移行し、間違ったことを不可能にする(最低でも明確にする)ことができます。

### 検査とアサーション

#### 検査

コードでの契約条件を強制するために広く使われている方法として、**検査(checks)** があります。検査は **早い失敗(Failling fast)** と密接に関連しています。検査は、例外処理で実装します。  

#### アサーション

多くのプログラミング言語は、**アサーション(assertions)** をサポートしています。コードでの契約を強制するという意味では、検査と概念的に似ています。  
アサーションと検査の違いは、アサーションはリリースビルドの際に無効にすることです。ただし、アサーションをリリースビルドでもそのまま無効にするという開発チームも多くあります。  

### まとめ

- コードベースは、複数のエンジニアが常に変更を加える
- 他のエンジニアがどのようにコードを壊したり誤用したりするかを考え、起こる可能性を最小限にするようにうまく処理することは役に立つ
- 私たちがコードを書く際、常にコードでの契約のようなものを作っている。コードでの契約は、見逃せない「明確な部分」と「細則に似た部分」を含んでいる
- 細かいコメント(細則)は、他のエンジニアに契約を遵守させる方法として信頼できるものではない。物事を明確にすることがよりよいアプローチである
- 通常、コンパイラーを利用して契約を強制することが最も信頼できるアプローチである。それが不可能ならば、検査とアサーションを利用した実行時における契約の強制が代替案である

## エラー

### 回復可能性

本セクションでは、回復可能/不可能なエラーの意味について説明します。  

#### 回復可能なエラー

エラーから回復してほしい例：  

- ユーザーからの無効な入力
- ネットワークエラー
  - リトライ
  - ユーザーにネットワークの接続確認をお願いする
- 深刻ではないタスクエラー

#### 回復不可能なエラー

回復不可能な例：  

- 画像やテキストファイルといったリソースがない
- コードを誤用している
  - 無効な入力で関数を呼び出している
  - 必須な事前の初期化がされていない

エラーから回復する方法を思いつかない場合にコードが取れる唯一の適切な行動は、エンジニアが問題に気づいて修正する可能性を最大化( **早い失敗と目立つ失敗** )することです。  

### 堅牢性 vs 失敗

エラーが起きたとき、次のどちらかを選ぶ必要があります。   

- 処理の失敗と判断して、上位レイヤーにエラーの処理を任せるか、プログラム全体をクラッシュさせる
- エラーを処理して動作を続ける

動作を続けるほうがコードが堅牢になることもありますが、しかしそれは、エラーが無視され、おかしな挙動が起こり始める可能性も示しています。  

#### 早い失敗

**早い失敗(Fail fast)** では、できる限り問題が起きた場所の近くでエラーを通知することを担保します。  

- 回復可能なエラーの場合、早い失敗は、呼び出し元がエラーから適切かつ安全に回復できる可能性を最大化します
- 回復不可能なエラーの場合、エンジニアがすばやく問題を特定して修正できる可能性を最大にします  

どちらのケースでも、意図しない状態や潜在的に危険な状態になることを防がなければなりません。  

これらの共通の例として、無効な引数で関数が呼び出された場合が挙げられます。無効な引数で関数が呼び出されると、すぐにエラーをスローします。これは、無効な引数が他のどこかで問題を発生させていることに後々エンジニアが気づくまで、動作を継続するのとは対照的です。  
早く失敗しない場合、実際に起きた場所から遠く離れた場所だけで起きる可能性があります。これにより、実際にエラーが起きた場所まで遡って修正するという、膨大な作業を要する可能性があります。  
早く失敗する場合、エラーは実際に起きた場所の近くで現れ、多くの場合、スタックとレースはエラーが起きたコードの行番号をエンジニアに提供します。  

コードが早く失敗しないと、デバッグしにくくなるだけでなく、ソフトウェアの足を引っ張ってダメージを与える可能性もあります。バグが数ヵ月後にようやく発見されるまでに、重要なデータを恒久的に壊している可能性も高いでしょう。  

バグがある際にコードが確実に吠える(かつ目立って吠える)ことが重要です。これは **目立つ失敗** として知られています。  

#### 目立つ失敗

目立つ失敗は、エラーを見逃さないように担保します。最も明確で(荒っぽい)方法は、例外をスローしてプログラムをクラッシュさせる(あるいは、それに近いことをさせる)ことです。  
エラーメッセージをログに出すことは、他のログのノイズに隠れて無視されてしまうことがあります。  

#### 回復可能かどうかの範囲

一般論として、ソフトウェアを堅牢にしようとすることは良いことです。クライアントからの1つの不適切なリクエストのためにサーバー全体をクラッシュさせるのは、よいアイデアではないのです。しかし、**エラーが確実に見過ごされないようにすることも重要** です。そう考えると、コードは目立って失敗すべきです。つまり、堅牢であることと、目立って失敗すること、この2つの目的は対立している場合が多いのです。目立って失敗するためにはプログラムをクラッシュさせますが、それは同時に堅牢性を損ないます。  

この対立に対する答えは、プログラミングエラーが検知されたら、エンジニアがそれに確実に気づく方法で記録してモニタリングすることです。

#### エラーを隠さない

エラーを隠すことは、回復可能/回復不可能なエラー、どちらの場合でも問題になり得ます。  
エラーが起きた事実を隠すパターンの例をいくつか挙げます。

・デフォルト値を返して、エラーが起きた事実を隠してしまう例：  
```
class AccountManager {
    private final AccountStore accountStore;

    Double getAccountBalanceUsd(Int customerId) {
        AccountResult result = accountStore.lookup(customerId);
        if (!result.success()) {
            return 0.0;   // エラーが起きた際にデフォルトの値を返してしまう
        }
        return result.getAccount().getBalanceUsd();
    }
}
```
エラーが起きて期待された値を返すことができない場合、デフォルトの値を返せばシンプルになったように見えます。しかしこれは、エラーが起きたという事実を隠すことです。呼び出し元はデフォルト値が正しいのか正しくないのか判断がつきません。  
たとえば、このコードが顧客の口座残高を返すコードだったしたらどうでしょうか？顧客はパニックを起こすでしょう。  

エラー処理に関しては、デフォルトの値を返すことは適切なことはほとんどありません。  

・nullオブジェクトパターン(空のオブジェクト)で、エラーが起きた事実を隠しまう例：  
```
class InvoiceManager {
    private final InvoiceStore invoiceStore;

    List<Invoice> getUnpaidInvoices(Int customerId) {
        InvoiceResult result = invoiceStore.query(customerId);
        if (!result.success()) {
            return [];    // エラーが起きた際に、空のリストを返してしまう
        }
        return result
            .getInvoices()
            .filter(invoice -> !invoice.isPaid());
    }
}
```
デフォルト値を返すパターンと同じで、空のリストが正しいのか正しくないのかが呼び出し元からは分かりません。  

・何もしないで、エラーが起きた事実を隠してしまう例： 
```
class MutableInvoice {

    void addItem(InvoiceItem item) {
        if (item.getPrice().getCurrency() != this.getCurrency()) {
            return;   // 通貨が違った場合、何もせずにリターンしてしまう
        }
        this.items.add(item);
    }
}
```
呼び出し元からは正しく処理されたのか分かりません。  

### エラーを通知する方法

エラーが起きた際、一般的には上位レイヤーのプログラムに通知する必要があります。  

回復不可能なエラーの場合、通常は最も上位のレイヤーのプログラムで処理を中断してエラーをログに記録する、もしくはプログラム全体を終了する(またはクラッシュさせる)必要があることを意味します。  

回復可能な場合、適切にエラーを処理できるように、直接の呼び出し元(またはそれよりも上の呼び出し元)に通知することを意味します。  

エラーを通知する方法は利用している言語がサポートしているエラー処理の機能によります。エラーに応じた失敗を通知する方法は、大まかに次の2つに分類されます。  

- 明示的：エラーが起きる可能性を、呼び出し元に強制的に意識させる。
- 暗黙的：エラーが起きるかどうかを呼び出し元が知るためには、コードのドキュメントを読むといった自発的なアクションが求められる。

明示的および暗黙的なエラーの通知方法の例：  

| | 明示的にエラーを通知するテクニック | 暗黙的にエラーを通知するテクニック |
|---|---|---|
| コードでの契約上の位置 | 紛れもなく明確な場所 | ドキュメントにある場合は細かいコメント。あるいは、細かいコメントすらない |
| 呼び出し元はエラーが起きることを認識できるか | はい | おそらく |
| テクニックの例 | ・検査例外<br>・null許容型の戻り値(null安全がサポートされている場合)<br>・オプショナル型の戻り値<br>・Result型の戻り値<br>・エラーを示す戻り値(値の確認を強制する場合)<br>・Swiftのエラー | ・非検査例外<br>・マジックバリューの戻り値(避けるべき)<br>・アサーション<br>・Promise型がFuture型<br>・検査(実装に依存)<br>・パニック |

#### 例外

多くのプログラミング言語は、**例外** の概念を持っています。例外は、コードからエラーや例外的な状況を通知する方法として設計されています。  
例外がスローされたとき、その例外を処理する呼び出し元にぶつかるか、そうでなければ最後までコールスタックを巻き戻します。この時点で、プログラムは中断されます。  

Javaには、検査例外と非検査例外の両方の概念があります。例外をサポートする多くのプログラミング言語では、非検査例外の概念のみを持っているので、Java以外で例外という単語を使う際は、通常は非検査例外を指します。  

#### 明示的：検査例外

Javaでは、検査例外をスローする関数は、検査例外をスローすることを示さなければなりません。関数の呼び出し元も検査例外をキャッチする処理を組み込まなければ、コンパイルエラーとなります。  
呼び出し元に何らかの形で例外を強制的に認識させるため、例外検査は明示的にエラーを通知するテクニックです。  

#### 暗黙的：非検査例外

非検査例外を使うと、他のエンジニアは、コードがエラーをスローすることにまったく気づかないことがあります。非検査例外のエラーのキャッチは強制ではないからです。関数がどんな非検査例外をスローするかは、ドキュメントに書いておくしかありません。  
呼び出し元がエラーに気づく保証はないため、非検査例外は暗黙的にエラーを通知するテクニックといえます。  

非検査例外をスローする例：  
```
/**
 * @throws NegativeNumberException 値が負の場合
 */
Double getSquareRoot(Double value) {
    if (value < 0.0) {
        // エラーの場合は非検査例外をスローする
        throw new NegativeNumberException(value);
    }
    return Math.sqrt(value);
}
```
上記の例では、スローする可能性がある非検査例外をドキュメント(コメント)として残しています。

上記の例の関数を使用して、非検査例外を処理します。  
非検査例外をキャッチする例：  
```
void displaySquareRoot() {
    Double value = ui.getInputNumber();
    try {
        ui.setOutput("平方根は " + getSquareRoot(value));
    } catch (NegativeNumberException e) {
        ui.setError("次の値の平方根を計算できません: " + e.getErroneousNumber());
    }
}
```
非検査例外は暗黙的なエラーを通知する方法なので、スローされた例外をキャッチしなくてもコンパイルエラーとなりません。  
非検査例外をキャッチしない例：
```
void displaySquareRoot() {
    Double value = ui.getInputNumber();
    ui.setOutput("平方根は " + getSquareRoot(value));
}
```

#### 明示的：null許容型の戻り値

使用している言語がnull安全をサポートしている場合、呼び出し元は戻り値がnullである可能性を認識し、それに応じた処理をしなければなりません。  
null安全がサポートされている言語を使用している場合にnull許容型を戻り値の型として利用することは、明示的にエラーを通知するテクニックとなります。  

null安全をサポートしていない言語を使用している場合、代替案としてオプショナル型を使うとよいでしょう。  

null許容型を使用できる言語で、nullを使って通知する例：
```
/**
 * 負の値が渡された場合はnullを返します   // なぜnullを返すのかを説明するコメントを残す
 */
Doulbe? getSquareRoot(Double value) {  // 「?」はnullが返される可能性を示す
  if (value < 0.0) {
    // エラーが起きた場合nullを返す
    return null;
  }

  return Math.sqrt(value);
}
```
nullを処理する例：  
```
Double? squareRoot = getSquareRoot(ui.getInputNumber());

if (squareRoot == null) {
  ui.setError("負の値から平方根は計算できません");
else {
  ui.setOutput("平方根は" + squareRoot);
}
```
null許容型では、nullの検査を強制します。ただし、null許容型を非null許容型にキャストできてしまうため、必ずしも強制できるわけではありません。しかし、これは意図的になされることであり、依然として値がnullである可能性を認識する必要があります。  

#### 明示的：Result型の戻り値

null許容型、オプショナル型を返すことの問題の1つは、エラーの理由を何も伝えていないことです。  
Swift、Rustなどの言語は、**Result型** を簡単に使うための便利な文法を組み込んでサポートしています。Result型をサポートしていない言語では、独自のResult型を定義して使用します。  

独自のシンプルなResult型の例：
```
class Result<V, E> {    // ジェネリクス(テンプレート)を使用
    private final Optional<V> value;
    private final Optional<E> error;

    // 呼び出し元にファクトリーメソッドを使わせるために、プライベートにしたコンストラクタ
    private Result(Optional<V> value, Optional<E> error) {
        this.value = value;
        this.error = error;
    }

    static <V, E> Result<V, E> ofValue(V value) {
        return new Result(Optional.of(value), Optional.empty());
    }

    static <V, E> Result<V, E> ofError(E error) {
        return new Result(Optional.empty(), Optional.of(error));
    }

    Boolean hasError() {
        return error.isPresent();
    }

    V getValue() {
        return value.get();
    }

    E getError() {
        return error.get();
    }
}
```
Result型を返す関数と独自のエラークラスの例：  
```
// 独自のエラークラス
class NegativeNumberError extends Error {
    private final Double erroneousNumber;

    NegativeNumberError(Double erroneousNumber) {
        this.erroneousNumber = erroneousNumber;
    }

    Double getErroneousNumber() {
        return erroneousNumber;
    }
}

// Result型を返す関数
Result<Double, NegativeNumberError> getSquareRoot(Double value) {
    if (value < 0.0) {
        // エラーが起きた場合はエラーの結果を返す
        return Result.ofError(new NegativeNumberError(value));
    }
    return Result.ofValue(Math.sqrt(value));
}
```
Result型を処理する(受け取る)処理の例：  
```
void displaySquareRoot() {
    Result<Double, NegativeNumberError> squareRoot = getSquareRoot(ui.getInputNumber());
    if (squareRoot.hasError()) {    // エラーチェック
        ui.setError("負の値から平方根は計算できません: " +
            squareRoot.getError().getErroneousNumber());  // 詳細なエラー情報
    } else {
        ui.setOutput("平方根は" + squareRoot.getValue());
    }
}
```

#### 明示的：エラーを示す戻り値

関数がエラーを示す戻り値を返すようにするのも1つのアプローチです。呼び出し元にその結果を検査することを **強制できれば** 、エラーを示す戻り値は明示的にエラーを通知するテクニックといえます。  

いくつかの言語では、呼び出し元が関数の戻り値を無視した際に、コンパイラーが警告を出すように設定できます。  

- Java の CheckResultValue
- C# の MustUseReturnValue
- C++ の [nodiscard] 属性

#### 暗黙的：Promise型かFuture型

コードを非同期に実行する場合、一般的に **Promise型** か **Future型** (もしくは同等の概念を持った型)の値を返す関数を作ります。多くの言語では、Promise型とFuture型はエラーを伝えることができます。  

### まとめ

- エラーは、大きく分けて2種類ある
  1. システムが回復可能なもの
  2. システムが回復不可能なもの
- コードの呼び出し元のみが、スローされたエラーから回復したいかどうかを知っている場合が多い
- エラーが起きた際は、早く失敗し、回復不可能なエラーならば目立って失敗するほうがよい
- エラーを隠すことはよいアイデアではなく、エラーが起きたことを通知したほうがよい
- エラーを通知するテクニックは、2つのカテゴリーに分けられる
  1. 明示的
  2. 暗黙的
- 回復不可能なエラーに関しては、暗黙的なエラーを通知するテクニックを使うべきである
- 回復したい可能性のあるエラーに関しては、次のとおりである
  - エンジニアの間では、明示的なテクニックか暗黙的なテクニックを使うべきかで意見が分かれている
  - (この書籍の)筆者個人の意見は、明示的なテクニックを使うべきである
- コンパイラーの警告を無視しない

# 実践編

## コードを読みやすくする

読みやすさの本質とは、あるコードを見たときに何をしているのかをすばやく正確に理解できるように担保することです。これを本当に達成するには、他のエンジニアの視点から見たときに、物事がいかに混乱を招き誤解されやすいかを想像してみることが必要になります。  

### わかりやすい名前を使う

- わかりづらい名前は、コードを読みにくくする
- わかりづらい名前にコメントを付けた場合、コメントもメンテナンスしなければならない

### コメントを適切に使う

コード内のコメントやドキュメントは、次の目的を果たします。  

- あるコードが **何を** しているのかの説明
- あるコードが **なぜ** そのコード内容を行っているかの説明

### コードの行数にこだわらない

コードの行数は、わたしたちが気にかける必要のあるコードの品質を表す指標の単なる1つであり、厳格なルールではありません。わたしたちが気にかける必要があるのは、コードが次の状態になるように担保することです。  

- わかりやすい
- 誤解されづらい
- 想定外の事態で壊れにくい
- 簡潔ではあるものの、理解できないコードは避ける

簡潔ではあるものの、理解できないコードの例：
```
Boolean isIdValid(UInt16 id) {
  return countSetBits(id & 0x7FFF) % 2 == ((id & 0x8000) >> 15);
}
```
このコードは簡潔に見えますが、ほとんど理解できないでしょう。複数のエンジニアが、この機能を理解しようとして多くの時間を無駄にする可能性があります。

### 一貫したコーディングスタイルにこだわる

一貫性のないコーディングスタイルは、混乱を招くリスクがあります。  

組織やチームで、一貫したコーディングスタイルを採用しましょう。スタイルガイドがない場合は、既製のものが多数公開されているので、取り入れましょう。

### ネストの深いコードは避ける

深くネストしたコードは読みにくいコードになっています。解決策として以下のような対策があります。

- 小さな関数に分割する
- if文をネストせずに、return 文で早く返す

### 関数の呼び出しを読みやすくする

関数に適切な名前を付けられていれば、関数が何をするのかは明らかなはずです。しかし、適切な名前が付けられた関数であっても、以下のような場合は読んでも理解できない関数になってしまいます。  

- 引数の目的や機能が明確でない
- 引数の数が増えるにつれて読みにくくなる

上記の問題を防ぐには、以下のような解決策があります。  

- 説明的な型を使用する
- 名前付き引数を使用する(名前付き引数がサポートされている場合のみ)

一部のIDEは、関数の定義を読みやすくするためにコードの表示を拡張する機能を持っており、非常に便利です。しかし、この機能に頼らないことをお勧めします。IDE以外のツール(マージツール、コードレビューツールなど)は、表示を拡張するような機能を備えていない可能性が高いからです。

### 説明のない値を使用しない

説明のない値を使用している例：
```
Double getKineticEnergyJ() {
  return 0.5 * getMassUsTon() * 907.1847 *
          Math.pow(getSpeedMph() * 0.44704, 2);
}
```

上記のコードは、以下のようないくつかの改善が可能です。  

1: 値を説明した適切な名前の付いた定数の例：
```
const Double KILOGRAMS_PER_US_TON = 907.1847;
const Double METERS_PER_SECOND_PER_MPH = 0.44704;

Double getKineticEnergyJ() {
  return 0.5 * getMassUsTon() * KILOGRAMS_PER_US_TON *
           Math.pow(getSpeedMph() * METERS_PER_SECOND_PER_MPH, 2);
}
```

2: プロバイダー関数(適切な名前の関数)を使用する例：
```
static double kilogramsPerUsTon() {
    return 907.1847;
}

static double metersPerSecondPerMph() {}
  return 0.44704;
}

double getKineticEnergyJ() {
  return 0.5 * getMassUsTon() * kilogramsPerUsTon() *
           Math.pow(getSpeedMph() * metersPerSecondPerMph(), 2);
}
```
3: ヘルパー関数を使用する例：
```
static double usTonsToKilograms(double usTons) {
    return usTons * 907.1847;
}

static double mphToMetersPerSecond(double mph) {
    return mph * 0.44704;
}

double getKineticEnergyJ() {
  return 0.5 * getMassUsTon() * kilogramsPerUsTon() *
           Math.pow(mphToMetersPerSecond(getSpeedMph()), 2);
}
```

### 無名関数を適切に使用する

ほとんどの主要な言語は、何らかの形で無名関数をサポートしています。小さくて自明なものを表すために無名関数を使用すると、コードの読みやすさは向上します。  

しかし、大きくて自明でないものや、再利用される可能性があるものを無名関数にすると、問題が起きる可能性があります。  

関数名は、関数内のコードが何をするのかを簡潔にまとめているため、コードの読みやすさの向上にとても役立ちます。文字通り、無名関数は名前がないため、コードを読んでいる人に対して、関数の要約という情報を提供しません。どんなに小さな無名関数であっても、その関数の内容が自明でない場合、コードは読みにくくなる可能性があります。

- 自明でない無名関数を作らない
- 大きな無名関数を作らない
- 再利用される可能性がある場合は、名前付きの関数にする

### すばらしい新しい言語機能を適切に使用する

多くのプログラミング言語は現在も活発に開発されており、時折すばらしい新機能がアップデートで追加されます。新機能によってコードが大幅に読みやすくなったり、堅牢になったりすることが多々あります。  

しかし、新しい機能がが本当に目の前の処理に最適な機能であるかは、自分自身に必ず問いかけてください。よく知られていない機能は混乱を招く可能性があります。その機能について他のエンジニアがどれだけ詳しく知っているかを考慮することが重要です。

### まとめ

- コードが読みにくく理解しづらい場合、次のような問題を起こす可能性がある
  - 他のエンジニアがコードを読んで理解するために時間を浪費している
  - バグを発生させるような誤解が生じる
  - 他のエンジニアが変更するとコードが壊れる
- コードを読みやすくすると、かえってコードが冗長になり行数が増える場合もある。しかし、たいていの場合は価値のあるトレードオフになる
- コードを読みやすくするには、他の人に対して親身になり、何が混乱を招くのかを想像することが必要

## 想定外の事態をなくす

### マジックナンバー(直値)を戻り値に使わない

戻り値にマジックナンバーを使ってしまう一般的な例は、エラーを表す戻り値として「-1」を返してしまうことです。呼び出し元がエラーを表す戻り値に注意を払っていない場合、ただの戻り値と間違えて処理してしまう可能性があります。これはバグにつながる可能性が高くなります。  

### nullオブジェクトパターンを使用することが本当に適切なのか考える

nullオブジェクトパターンを使用することは、多くの場合において **悪いアイデア** です。nullオブジェクトパターンを使用することが本当に適切なのか、または想定外の事態を起こす可能性があるのかを考えることが大切です。  

null安全とオプショナル型などを使って、明示的に通知するほうが遥かに簡単かつ安全です。

### 予期せぬ副作用の発生を避ける

**副作用** とは、関数を呼び出したときに、その関数が戻り値以外で関数の外側の状態を変更する(影響する)ことを指します。  
副作用が、コードの呼び出し元が期待しているもので必要な場合は問題ありません。しかし、それが予期せぬ場合は、想定外の事態を起こしてバグにつながる可能性があります。  

副作用の例：  
```
Color getPixel(Int x, Int y) {
  canvas.redraw();             // キャンバスの再描画イベント
  PixelData data = canvas.getPixel(x, y)
  return new Color(data.red, data.green, data.blue);
}
```
上記の例は、特定のピクセルの色を取得する関数の実装です。呼び出し元はピクセルの色を取得したいだけですが、キャンバスの再描画イベントが発生しています。多くの場合、再描画は実行コストが高いためです。また、このタイミングで再描画が行われては困る場合もあります。これは副作用であり、予期せぬバグにつながる可能性があります。

これを解決するには、副作用を回避する、もしくは明白にすることです。

副作用を回避する例：  
```
Color getPixel(Int x, Int y) {
  PixelData data = canvas.getPixel(x, y)
  return new Color(data.red, data.green, data.blue);
}
```
再描画イベントを削除し、関数名のとおりの動作にしています。

副作用を明白にする例：  
```
Color redrawAndgetPixel(Int x, Int y) {
  canvas.redraw();
  PixelData data = canvas.getPixel(x, y)
  return new Color(data.red, data.green, data.blue);
}
```
関数名をredrawAndgetPixelに変更し、副作用を明白にしています。  

### 引数の変更に注意する

書き換えてはいけない関数の引数の値を関数内で変更(書き換え)してしまうと、予期せぬ副作用もしくはバグが発生します。特に参照型の変数が引数の場合には注意が必要です。  

解決策としては、変更する前にコピーすることです。  
値をコピーすると、コードのパフォーマンス(メモリやCPUの使用量など)に明らかな影響を与える可能性があります。低性能のハードウェアで実行する可能性が高い場合、引数を変更しなければならない場合もあります。このようなパフォーマンス上の理由などで引数の値を変更する必要がある場合は、関数名・すべてのドキュメントの中で変更を明確にしておきましょう。  

### 誤解を招くような関数の書き方を避ける

エンジニアは、関数を呼び出すコードを見ると、それを基に何が起こっているかを推測します。関数の名前や入力値などは、コードでの契約としてエンジニアがコードをパッと見たときに主に目をするものです。
この契約の部分に大切な何かが欠けていると、想定外の事態を起こす可能性があります。  

#### 重要な入力値が欠けているときに何もしないと、想定外の事態を起こす可能性がある

何もしない例：  
```
void displayLegalDisclaimer(String? legalText) {  // legalTextはnullの可能性がある
    if (legalText == null) {
        return;   // 何も表示せずに終了してしまう
    }
    displayOverlay(legalText);
```
nullをdisplayLegalDisclaimer関数に渡したとき、この関数はユーザーに何も表示せずに終了してしまいます。  
displayLegalDisclaimer関数が法的免責事項を表示する重要な機能だとした場合、ユーザーに対して重大な事態を起こしてしまいます。  

### 将来的にも有効に使い続けられるように設計された列挙型処理

#### 将来の列挙型を暗黙的に処理すると、問題が発生する可能性がある

次のソースコードの例では、モデルが出力する予測結果が安全な結果かどうかを示す列挙型と関数になっています：
```
enum PredictedOutcome {
    COMPANY_WILL_GO_BUST,         // 安全ではない
    COMPANY_WILL_MAKE_A_PROFIT,   // 安全
}

  ...

Boolean isOutcomeSafe(PredictedOutcome prediction) {
    if (prediction == PredictedOutcome.COMPANY_WILL_GO_BUST) {
        return false;   // 安全ではない
    }
    return true;
}
```

このコードは列挙型が2つしかないときは機能します。しかし、誰かが新しい列挙型を導入した場合、バグが発生する可能性があります。

```
enum PredictedOutcome {
    COMPANY_WILL_GO_BUST,         // 安全ではない
    COMPANY_WILL_MAKE_A_PROFIT,   // 安全
    WORLD_WILL_END,               // 安全ではない
}
```
このまま実行すると、想定していない結果が出力されてしまいます。  

この例では列挙型の定義とisOutcomeSafe関数が近くに書かれていますが、実際はまったく別のファイルに書かれている可能性があります。最初に作成したエンジニアとは別のエンジニアがメンテナンスする可能性もあります。したがって、「列挙型を追加するエンジニアが、isOutcomeSafe関数も一緒に更新することを認識している」と想定するのは安全ではありません。  

解決策としては、全ケースを網羅したswitch文を使用します：  
```
Boolean isOutcomeSafe(PredictedOutcome prediction) {
    switch (prediction) {
        case COMPANY_WILL_GO_BUST:
            return false;
        case COMPANY_WILL_MAKE_A_PROFIT:
            return true;
    }

    // エラー発生。case内を通らずにswitchを抜けた場合に非検査例外をスローする
    throw new UncheckedException(
        "処理されていない予測: " + prediction);
}
```
isOutcomeSafeに渡す列挙型の全パターンのユニットテストと組み合わせて使用すると、潜在的なバグを回避することができます。  

#### デフォルトケースに注意する

通常、switch文はデフォルト(default)ケースをサポートしています。列挙型を処理するswitch文にデフォルトケースを追加すると、将来の列挙型が暗黙的に処理され、バグが発生する可能性があります。

列挙型を処理するデフォルトケースでバグが発生する可能性のある例：
```
Boolean isOutcomeSafe(PredictedOutcome prediction) {
    switch (prediction) {
        case COMPANY_WILL_GO_BUST:
            return false;
        case COMPANY_WILL_MAKE_A_PROFIT:
            return true;
        default:
            // 新しい列挙値が追加された場合、falseを返してしまう
            return false;
    }
}
```

解決策として、デフォルトケースからエラーをスローするようにします：
```
Boolean isOutcomeSafe(PredictedOutcome prediction) {
    switch (prediction) {
        case COMPANY_WILL_GO_BUST:
            return false;
        case COMPANY_WILL_MAKE_A_PROFIT:
            return true;
        default:
            // エラーをスロー
            throw new UncheckedException("処理されていない:" + prediction);
    }
}
```

### これらのすべてをテストで解決することはできないか？

(筆者の経験からすると) やや理想主義的な主張であり、実際にはうまくいきません。  
コードを書いた時点では、コードのテスト方法をあなた自身で制御できます。しかし、あなたのコードを呼び出す他のエンジニアが書いたコードが正しく機能するかを確認するには、テストだけでは確認するのに十分でない場合があります。  

テストはとても重要です。  
しかし、コードの構造やコードでの契約への配慮が、高品質で徹底的なテストに取って代わるわけではありません。

### まとめ

- 私たちが書いたコードに、他のエンジニアが書いたコードが依存していることがよくある
  - コードの呼び出しもとで想定外の事態が起きないようにする最善の方法の1つは、コードでの契約上の紛れもなく明確な部分に重要な詳細を示していることを担保することである
- 依存しているコードに対して壊れやすい想定をすると、別の想定外の事態を起こす可能性がある
- テストだけでは想定外の事態を起こすコードを網羅することはできない。

## 誤用しにくいコードを書く

### 誤用しにくい

何かを誤用しにくくする(または不可能にする)ことで問題を回避するという考えは、設計と製造において長年確立された原則です。**防御的設計**原則の共通の特徴です。  

例：
- フードプロセッサーの多くは、ふたが適切に取り付けられている場合のみに動作するように設計されている。こうすることで、誰かが怪我をしないように防いでいる。  
- ソケットとプラグは異なる形状になっている。例えば電源プラグにHDMIのコネクタは接続できない。

### すべてを不変にすることを検討する

不変性が望ましい理由を理解するには、反対の **可変性** がどのような問題を起こすかを考えることが重要です。  

- 可変なコードは推測しにくい
- 可変なコードは、マルチスレッドで問題を起こす可能性がある

#### 可変クラスは誤用されやすい

クラスを可変にする最も一般的な方法の1つは、セッター関数を提供することです。

可変性が原因となるバグの例：
```
class TextOptions {
    private Font font;
    private Double fontSize;

    TextOptions(Font font, Double fontSize) {
        this.font = font;
        this.fontSize = fontSize;
    }

    void setFontSize(Double fontSize) {   // セッター関数
        this.fontSize = fontSize;
    }

    Double getFontSize() {
        return fontSize;
    }
}

class MessageBox {
    private final TextField titleField;
    private final TextField messageField;

    void renderTitle(String title, TextOptions baseStyle) {
        baseStyle.setFontSize(18.0);  // フォントサイズを書き換えている
        titleField.display(title, baseStyle);
    }

    void renderMessage(String message, TextOptions style) {
        messageField.display(message, style);
    }
}

  :

// メイン
void main() {
    TextOptions defaultStyle = new TextOptions(Font.ARIAL, 12.0);
    messageBox.renderTitle("重要なメッセージ", defaultStyle);
    messageBox.renderMessage("Hello", defaultStyle);
}
```
上記の例では、メッセージをフォントサイズ12.0で表示したかったのですが、18.0で表示されてしまいます。  
これは、renderTitle関数内でbaseStyleの引数を書き換えてしまっているためです。renderTitle関数の関数名が適切ではないというバッドプラクティスも含んでいますが、途中でフォントサイズを変更するセッター関数が必要かを考える必要があります。  

解決策1:  
構築時のみに(コンストラクタの引数で)値を設定することです。すべての値を構築時に提供し、その後は変更できないようにすることで、クラスを不変に(そして誤用を防ぐことが)できます。  

解決策2:  
不変性を実現するデザインパターンを使用することです。

- ビルダーパターン
- コピーオンライトパターン

ビルダーパターン:  
setter関数や、クラス生成時の引数が多すぎるときに有効  

コピーオンライトパターン:  
```
class TextOptions {
    private final Font font;
    private final Double fontSize;

    // パブリックなコンストラクタ
    TextOptions(Font font) {
        this(font, 12.0);
    }

    // プライベートなコンストラクタ
    private TextOptions(Font font, Double fontSize) {
        this.font = font;
        this.fontSize = fontSize;
    }

    // フォントサイズのみを変更した新しいオブジェクト(インスタンス)を返す
    TextOptions withFontSize(Double newFontSize) {
        return new TextOptions(this.font, newFontSize);
    }
}

  :

// メイン
void main() {
  TextOptions defaultStyle = new TextOptions(Font.ARIAL);

  // 変更したコピーを作成
  newStyle = defaultStyle.withFontSize(18.0);
}
```

### すべてを深く不変にすることを検討する

エンジニアは不変性のメリットを認識していますが、クラスが思わず可変になってしまう曖昧な方法を見落としがちです。クラスが誤って可変になる典型的なパターンは、**深い可変性** が原因です。これは、メンバー変数が可変な型で、他のコードが何らかの方法でそれにアクセスできると生じる可能性があります。  
参照型の変数をメンバー変数として使用しているときは注意が必要です。  


解決策1:  
すべてを防御的にコピーして保持する  

例：
```
class TextOptions {
    private final List<Font> fontFamily;  // 参照型のメンバー変数
    private final Double fontSize;

    TextOptions(List<Font> fontFamily, Double fontSize) {
        this.fontFamily = List.copyOf(fontFamily);
        this.fontSize = fontSize;
    }

    List<Font> getFontFamily() {
        return List.copyOf(fontFamily);   // リストのコピーを返している
    }
}
```

すべてを防御的にコピーすることは、非常に効果的な方法ですが、いくつかのデメリットがあります。  

- コピーのコスト
- 多くの場合、クラス内からの変更を防いでいない


解決策2:  
不変のデータ構造を使用する  

例：  
- Java: ImmutableListクラス  
- C#: System.Collections.Immutable の ImmutableListクラス
- JavaScriptベースの言語: Immutable.jsモジュールのListクラス

データ構造ではありませんが、C++にはconst correctnessの考え方もあり、すべてを不変に保つためのよりよい方法です。  

### あまりにも汎用的なデータ型を避ける

整数やリストなどで何かを表すことができるからとって、それが本当にその何かを表すためのよい方法とは限りません。  

- あまりにも汎用的な型を使うと、コードを誤用する可能性がある  
  汎用的な型とは、整数、文字列、リスト型、など
- ペア型(tuple型)は誤用しやすい

解決策:  
専用のデータ型を使用する  
例: DDDのValue Objectの考え方など  

ショートカットすることは、中長期的に開発のスピードを落とす。あまりにも汎用的な型を使用することは、多くの場合において、ショートカットの例になります。新しいクラスや構造体を定義するのは多大な労力に感じたりしますが、エンジニアが頻繁に頭を悩ませる問題や将来の潜在的なバグを回避できます。  

### 時間の扱い

整数で時刻を表すと、問題が発生する可能性があります。  

- 単位の不一致  
- タイムゾーンの扱いを間違える

解決策:  
時間に適切なデータ構造を使用する  

### データに対して信頼できる唯一の情報源を持つ

多くの場合、コードはデータを次の2つの形式で提供します。  

- 一次データ：コードに提供する必要があるもの
- 二次データ：一次データに基づいてコードが計算できるもの

この例として、銀行口座の状態を説明するのに必要なデータが挙げられます。下記のコードの例では、一時データが貯金、借りたお金、です。二次データは口座残高です。  

例：  
```
class UserAccount {
  private final Double credit;    // 貯金
  private final Double debit;     // 借りたお金
  private final Double balance;   // 口座残高

  // すべての金額情報をコンストラクタで受け取る
  UserAccount(Double credit, Double debit, Double balance) {
      this.credit = credit;
      this.debit = debit;
      this.balance = balance;
  }

  Double getCredit() {
      return credit;
  }

  Double getDebit() {
      return debit;
  }

  Double getBalance() {
      return balance;
  }
}

  ...

// 間違えた情報でインスタンスを作成してしまう
//   ×借りたお金 - 貯金
//   〇貯金 - 借りたお金
UserAccount acount = new UserAccount(credit, debit, (debit - credit));
```
上記の例は、論理的に間違えています。  
一次データは、通常、信頼できる情報源を提供します。上記のコードの例では、複数の信頼できる情報源の存在が、不正な状態につながってしまっていると言えます。  

改善例：
```
class UserAccount {
  private final Double credit;    // 貯金
  private final Double debit;     // 借りたお金
 
  UserAccount(Double credit, Double debit) {
      this.credit = credit;
      this.debit = debit;
  }

  Double getCredit() {
      return credit;
  }

  Double getDebit() {
      return debit;
  }

  Double getBalance() {
      // 口座残高は計算する
      return credit - debit;
  }
}
```
口座残高は変数で保持するよりも、必要に応じて計算するほうが遥かによい方法です。  

### まとめ

- コードが誤用されやすい場合、いつか誤用される可能性は高い。その結果として、バグの発生に繋がる
- コードが誤用される可能性のある典型的なパターンは、次のとおり
  - 呼び出し元が不正な入力を渡す
  - 他のコードからの副作用
  - 呼び出し元が正しいタイミングまたは正しい順序で関数を呼び出していない
  - 想定から外れるように変更された関連コード
- 多くの場合、誤用しにくい、またはできなくなるように、コードを設計および構造化できる。こうすることで、バグの発生の可能性が大幅に減少し、エンジニアは中長期的に多くの時間を節約できる

## コードをモジュール化する

本章は、きれいな抽象化レイヤーの考えに大きく基づいています。多くの場合、コードをモジュール化することは、それぞれ自己完結型にして、お互いに蜜結合していないことを担保するところに辿り着きます。  
これにより、コードの要件変更への対応力が向上するだけでなく、ソフトウェアが分かりやすくなる傾向があります。  
また、コードをモジュール化することは、コードを再利用しやすく、テストしやすくする傾向があるなど、多くのメリットがあります。  

### DIを使用する

クラスが他のクラスに依存することは、ごく普通のことです。  

#### ハードコーディングされた依存関係

次のコードの例は、車の旅のルートの計画を実装するクラスのコードの一部を示しています。  

```
// 車の旅のルートの計画のクラス
class RoutePlanner {
    private final RoadMap roadMap;  // RoadMapに依存している

    RoutePlanner() {
        this.roadMap = new NorthAmericaRoadMap();
    }

    Route planRoute(LatLong startPoint, LatLong endPoint) {
        ...
    }
}

// インターフェイスクラス
interface RoadMap {
    List<Road> getRoads();
    List<Junction> getJunctions();
}

// 北米向けRoadMapの実装クラス
class NorthAmericaRoadMap implements RoadMap {
    ...
    override List<Road> getRoads() { ... }
    override List<Junction> getJunctions() { ... }
}
```
RoutePlannerクラスは、RoadMapのインスタンスに依存しています。RoadMapは、地域ごとに多くの実装を持つインターフェイスです。にもかかわらず、RoutePlannerクラスはコンストラクタでNorthAmericaRoadMapのインスタンスを生成します。これは、RoadMapの特定の実装に対してハードコーディングされた依存関係があるとことを意味しています。  
つまり、今のRoutePlannerクラスは、北米での旅の計画のみに使用でき、他の地域を計画するには役に立ちません。  

改善例：  
```
class RoutePlanner {
    private final RoadMap roadMap;

    RoutePlanner(RoadMap roadMap) {
        this.roadMap = roadMap;
    }

    Route planRoute(LatLong startPoint, LatLong endPoint) {
        ...
    }
}
```
```
// 北米向け
RoutePlanner northAmericaRoultePlanner = new RoutePlanner(new NorthAmericaRoadMap());

// ヨーロッパ向け
RoutePlanner europeRoultePlanner = new RoutePlanner(new EuropeRoadMap(true,false));
```
呼び出し元は、任意の地域のロードマップを使用してRoutePlannerのインスタンスを構築できるようになりました。  

このようにRoadMapを注入することによるデメリットは、RoutePlannerクラスの構築がより複雑になることです。地域ごとにRoadMapの引数のパターンが各種ある場合、不具合の可能性が高まります。この場合は、ファクトリー関数などを用意して構築できるようにします。  

ファクトリー関数の例：  
```
class RoutePlannerFactory {
    static RoutePlanner createDefaultNorthAmericaRoutePlanner() {
        return new RoutePlanner(new NorthAmericaRoadMap());
    }

    static RoutePlanner createEuropeRoutePlanner() {
        return new RoutePlanner(new EuropeRoadMap(true, false));
    }
}
```

#### DIを念頭に置いてコードを設計する

コードを書くとき、DIの必要性を意識的に検討すると、多くの場合で約に立つでしょう。DIが必要だとわかっている場合は、DIが不可能にならないコードを避けるのが最善です。特に、静的(static)関数、静的変数への依存は潜在的な問題がよく知られています。ユニットテストで問題になる可能性があります。  

### インターフェイスに依存する

依存関係逆転の原則：  
より具体的な実装ではなく、抽象に依存するほうがよいという考えの中心には、依存関係逆転の原則があります。この設計原則の詳細については、[https://stackify.com/dependency-inversion-principle/](https://stackify.com/dependency-inversion-principle/) を参照してください。

### クラスの継承に注意

クラスの継承は間違いなく使いどころがあります。2つのクラスに 真の **is -a関係** がある場合、継承が適切である可能性のサインです。継承は強力なツールですが、いくつかのデメリットもあり、それによって発生する問題は、とても許容できない場合もあります。継承するコードを書く前に、慎重に検討してください。  
多くのシナリオにおいて、継承の代替手段は **コンポジション(composition)** を使用することです。  

#### ミックスイン(Mixin)とトレイト(trait)

ミックスインとトレイトは、一部の言語がサポートしている機能です。多重継承と問題のあるクラス階層が抱えるいくつかの問題を克服するのに役立ちます。ただし、クラスの継承と同様に、きれいな抽象化レイヤーを作らず、さほど変更に対応しやすいわけではないため、使用には注意と考慮が必要です。  

サポートしている言語：

- ミックスイン
  - Dart
  - TypeScript
- トレイト
  - Rust
  - JavaとC#の最近のバージョン

### クラスは自分自身に関心を持つべき

1つの概念が完全に1つのクラスの中に閉じている場合、この目的はほぼ実現できています。逆に、1つの概念が複数のクラスにまたがっている場合があります。その概念に関連する要件を変更すると、複数のクラスを変更しなければならなくなります。そして、エンジニアがこのうちの1つを変更し忘れると、バグが発生する可能性もあります。  
このようなことが起こるパターンは、あるクラスが別のクラスの詳細に関心を持ちすぎている場合です。  

別のクラスの詳細に関心を持ちすぎている例：  
```
class Book {
    private final List<Chapter> chapters;
    ...

    // 本に含まれる単語数を返す
    int wordCount() {
        return chapters.map(getChapterWordCount).sum();
    }

    // 各章の単語数を返す
    private static int getChapterWordCount(Chapter chapter) {
        return chapter.getPrelude().wordCount() +
            chapter.getSections()
                .map(section -> section.wordCount())
                .sum();
    }
}

class Chapter {
    ...

    TextBlock getPrelude() { ... }
    List<TextBlock> getSections() { ... }
}
```
getChapterWordCount関数はBook関数にあるにもかかわらず、Chapterクラスの要素のみを使って処理しています。Chapterクラスの詳細がBookクラスにハードコーディングされてしまっているということです。

改善例：  
```
class Book {
    private final List<Chapter> chapters;
    ...

    int wordCount() {
        return chapters
            .map(chapter -> chapter.wordCount())
            .sum();
    }
}

class Chapter {
    ...

    TextBlock getPrelude() { ... }
    List<TextBlock> getSections() { ... }

    // 章内の単語をカウントするロジックがChapterクラス内で完全に閉じている
    int wordCount() {
        return getPrelude().wordCount() +
            getSections()
                .map(section -> section.wordCount())
                .sum();
    }
}
```

#### デメテルの法則

デメテルの法則（Law of Demeter）は、ソフトウェア設計、特にオブジェクト指向プログラミングにおける重要なガイドラインです。この法則の基本的な考え方は、「任意のオブジェクトが自分以外（サブコンポーネントを含む）の構造やプロパティに対して持っている仮定を最小限にすべきである」というものです。  

デメテルの法則を適切に適用することで、オブジェクト間の結合度を低く保ち、より柔軟で保守しやすいコードを作成することができます。ただし、どの原則でも、メリットと同様にデメリットについて考慮することが重要です。  

メリット:  
- ソフトウェアの保守性と適応性が向上します。
- テストや修正が容易になります。

デメリット:  
- 多くのラッパーメソッドを書く必要が生じ、時間と空間のオーバーヘッドが増加する可能性があります。
- クラスインターフェースが広くなり、多くの補助メソッドが必要になる場合があります

### 関連データをまとめてカプセル化する

クラスを使うと、あらゆるものをグループ化できます。あまりにも多くのものを1つのクラスにグループ化しようとした場合に問題が起こる可能性があります。一方で、グループ化することが理にかなっている際のメリットを見落とすべきではありません。

#### カプセル化していないデータは扱いにくい

扱いにくい例：  
```
class TextBox {
    void renderText(
        String text,
        Font font,
        Double fontSize,
        Double lineHeight,
        Color textColor) { ... }
}

class UiSettings {
    Font getFont() { ... }
    Double getFontSize() { ... }
    Double getLineHeight() { ... }
    Color getTextColor() { ... }
}

class UserInterface {
    private final TextBox textBox;
    private final UiSettings uiSettings;

    void displayMessage(String message) {
        textBox.renderText(
            message,
            uiSettings.getFont(),         // displayMessage関数は
            uiSettings.getFontSize(),     // テキストスタイルの
            uiSettings.getLineHeight(),   // 詳細を含んでいる
            uiSettings.getTextColor());   // 
    }
}
```
displayMessage関数が関心があるのは、UiSettingsが何らかのスタイル情報を提供していて、renderTextがそれらを必要としていることだけです。しかし、選択されているテキストスタイルを一緒にカプセル化していないため、displayMessage関数はテキストスタイルの詳細について知らなければなりません。

解決例：  
```
// テキストスタイル情報をまとめてカプセル化する
// TextOptionsクラス(データオブジェクト)を作成
class TextOptions {
    private final Font font;
    private final Double fontSize;
    private final Double lineHeight;
    private final Color textColor;

    TextOptions(Font font, Double fontSize,
                Double lineHeight, Color textColor) {
        this.font = font;
        this.fontSize = fontSize;
        this.lineHeight = lineHeight;
        this.textColor = textColor;
    }

    Font getFont() { return font; }
    Double getFontSize() { return fontSize; }
    Double getLineHeight() { return lineHeight; }
    Color getTextColor() { return textColor; }
}
```
```
class TextBox {
    void renderText(String text, TextOptions textStyle) { ... }
}

class UiSettings {
    TextOptions getTextStyle() { ... }
}

class UserInterface {
    private final TextBox messageBox;
    private final UiSettings uiSettings;

    void displayMessage(String message) {
        messageBox.renderText(
            message, uiSettings.getTextStyle());  // テキストスタイルに関する詳細な情報は含まれなくなる
    }
}
```

### 戻りの型から実装の詳細が漏洩することに注意する

きれいな抽象化レイヤーを作るには、レイヤーから実装の詳細が漏洩しないようにする必要があります。もし漏洩すると、コード内の下位レイヤーの詳細が外から見えてしまい、今後の変更や再構成が非常に難しくなることがあります。  

コードが実装の詳細を漏洩してしまう最も典型的なパターンの1つは、その詳細と密接に結合した型を返すことです。

### 例外の中から実装の詳細が漏洩することに注意する

戻り値と同じです。  
特に、非検査例外をcatch文でキャッチできず、プログラムがクラッシュしてしまう可能性もあります。

### まとめ

- 多くの場合、モジュール性の高いコードは要件の変更に対応しやすい
- モジュール化の主な目的の1つは、要件の変更の影響をその要件に直接関連するコードのみに限定すること
- コードをモジュール化することは、きれいな抽象化レイヤーを作ることに大きく関係している
- 次のテクニックを使用してコードのモジュール性を高めることができる
  - DIの使用
  - 具体的なクラスではなく、インターフェイスに依存する
  - クラスの継承の代わりにインターフェイスとコンポジションを使用する
  - クラスが自分自身に関心を持つようにする
  - 関連データをまとめてカプセル化する
  - 戻り値の型と例外から実装の詳細が漏洩しないようにする

## コードを再利用、汎用化しやすくする

### グローバル状態に注意する

- いわゆるグローバル変数
- JavaやC#などの言語では、変数をstaticとして定義した場合

グローバル状態を持ったコードは、1つだけ存在する、という暗黙の想定に頼ることにになり、コードを再利用することを完全に危険にする傾向があるため、たいていはコストがメリットを上回ってしまいます。
再利用したいと考えた場合に、ほぼ重複したコードを新たに作成しなければなりませんし、保守も重複して行わなければなりません。

グローバル状態は、プログラムのさまざまな場所で情報を共有するための迅速で簡単な方法のように思え、使用したくなることがあります。しかし、グローバル状態を使用していることを他のエンジニアがはっきりと認識していない可能性があるため、仮にコードの再利用をしようとしてしまった場合に、おかしな動作やバグが発生するかもしれません。

### デフォルト値を適切に使用する

最近のほとんどの言語では、関数の引数にデフォルト値を設定することが可能です。しかし、デフォルト値の提供には多くの場合、想定をする必要があります。

- デフォルト値が適切であること

### ジェネリクスの使用を検討する

多くの言語がジェネリクス(テンプレート)をサポートしています。  

たとえば多くの言語に組み込まれているListは特定の型に依存せずにリストを作成することができ、汎用化がしやすい作りになっています。  

例：  
```
List<String> stringList = ["Hello", "World"];

List<Int> intList = [1, 2, 3];
```

### まとめ

- 同じような小さな問題は何度も起きるため、コードを再利用しやすくすることで、将来の自分とチームメイトの時間と労力を大幅に節約できる
- 基本的な小さな問題を特定するように努め、他の人が別の上位レイヤーの問題を解決している場合でも、特定の小さな問題の解決策を再利用できるようにコードを構築すること
- きれいな抽象化レイヤーを作り、コードをモジュール化すると、たいていの場合、かなり簡単で安全にコードを再利用、汎用化しやすくする
- 多くの場合において、想定することはコードをより脆弱しく、再利用しづらくするという点でコストがかかる
  - 想定するメリットがコストを上回ることを確かめること
  - 本当に想定する必要がある場合は、それがコードの適切なレイヤーにあることを確かめ、可能であればその想定を強制する
- グローバル状態を使用すると、特別コストのかかる想定が紐付き、その結果、再利用すると全面的に危険なコードになってしまう。たいていの場合のシナリオでは、グローバル状態は避けるのが最善である

# ユニットテスト編

## ユニットテストの原則

ユニットテストに関して、覚えておくべきいくつかの重要な概念と用語があります。  

- テスト対象のコード：テストしようとしているコードを指す。「プロダクションコード」と呼ばれる。
- テストコード：ユニットテストを形成するコードを指す。
- テストケース
  - アレンジ(Arrange)：テストしたい特定の動作を呼び出す前に、いくつかのセットアップが必要な場合の動作を指す。
  - アクト(Act)：テスト対象の動作を実際に呼び出すコードを指す。
  - アサーション(Assert)：テスト対象の動作を呼び出したら、その正しさをテストで確認する。
- テストランナー：名前が示すように、テストランナーはテストを実行するツールを指す。

## よいユニットテストとは？

よいユニットテストが示すべき5つの重要な特徴を定義します。  

- 破損を正確に検出する
- 実装の詳細にとらわれない
- よく説明された失敗
- わかりやすいテストコード
- 簡単かつ迅速に実行する

### 破損を正確に検出する

ユニットテストは、次の2つの非常に重要な役割を果たします。

- コードに対して最初の信頼が得られる
- 将来の破損から保護する
  - コードの変更によって壊れた機能を「リグレッション」と呼ぶ
  - リグレッションを検出する目的で実行するテストを「リグレッションテスト」と呼ぶ

テストにおける「正しさ」とは、「テスト対象のコードが本当に壊れている場合のみに、テストは失敗すべき」ということです。「コードが壊れている場合、テストは確実に失敗する」ことは、必ずしも「コードが壊れている場合のみに、テストが失敗する」というわけではないのです。  

テスト対象のコードが正常であっても、パスすることもあれば失敗することもあるようなテストは、**フレーキー(flakey)** と呼ばれます。フレーキーなテストになるのは、ランダム性、タイミングベースの競合状態、外部システムへの依存などによって、不確定な動作が起こった結果です。

### 実装の詳細にとらわれない

大まかにいえば、エンジニアがコードベースに加える可能性のある変更には、次の2種類があります。

- 機能変更
- リファクタリング

リファクタリングは、コードを使用する人に影響を与えてはならないものです。実装の詳細を変更していますが、使用する人が気にする必要のある動作は変更しません。しかし、コードの変更にはリスクが伴い、リファクタリングも例外ではありません。

テストが実装の詳細にとらわれないようにすることで、コードをリファクタリングしている誰もが間違いを犯したかどうかを確認できる、信頼度が高く明白な合図があることを担保できます。

#### 機能変更とリファクタリングを混在しない

コードベースに変更を加える場合、機能変更とリファクタリングの両方を同時に行うことは避けてください。同時に行ってしまうと、動作の変更が、機能変更によって期待されたものなのか、リファクタリングで間違いを犯したことによるものなのか判断が難しくなってしまうことがあるからです。  
通常は、リファクタリングを行ってから、機能変更を行うほうが適切です。  

### よく説明された失敗

失敗したテストで何か壊れているかが示されていないと、何が問題かを理解するために、多くの時間を無駄にする可能性があります。  
テストで何が壊れているのかを明確かつ正確に説明するためには、何か問題があるときにテストが生成する失敗メッセージの種類と、これが他のエンジニアに役立つかどうかを考える必要があります。

問題を十分に説明していない例：
```
Test case testGetEvents failed:     // テストケースの名前(testGetEvents)がどの動作をテストしているかを示せていない
Expected: [Event#ea4a92b, Event#3c5a99da]
But was actually: [Event#3c5a99da, Event#ea4a92b]   // 失敗メッセージの解読が困難
```

よく説明された例：
```
Test case testGetEvents_inChronologicalOrder failed:     // テストケースの名前からどの動作をテストしているのかが明確
Contents match, but order differs
Expected:
[<Spaceflight, April 12, 1961>, <Moon Landing, July 20, 1969>]
But was actually:
[<Moon Landing, July 20, 1969>, <Spaceflight, April 12, 1961>]  // 失敗メッセージから問題の原因が明確にわかる
```

テストの失敗を明確に説明できるようにする最善の方法の1つは、一度に1つのことをテストする、各テストケースにわかりやすい名前を付けること、です。

### わかりやすいテストコード

新しい機能を反映するのに応じてテストを更新しなければなりません。エンジニアが変更を期待する動作のみに影響を与えていることを確認するには、テストのどの部分に影響を与えているかを理解する必要があります。そのためには、どんな種類のテストケースをテストしているか、また、どのようにテストしているかの両方について理解する必要があります。  

わかりやすいテストコードのもう1つの理由は、一部のエンジニアは、テストをコードの取り扱い説明書として使用することを好むためです。特定のコードの使い方や提供する機能について知りたいとき、ユニットテストを見ることはよい方法の1つです。しかし、テストがわかりにくい場合、あまり役立つ取り扱い説明書にはなりません。

### 簡単かつ迅速に実行する

たとえば、ユニットテストの実行に1時間かかると、すべてのエンジニアの作業が遅くなります。コードの変更をコミットする前に、それがどんなに小さな些細なものであったとしても、最低1時間はかかるからです。

もう1つの理由は、テストが遅いとテストを実行することが苦痛になり、エンジニアがテストをあまり行わなくなる傾向gあります。  

テストをできるだけ簡単かつ高速に実行できるようにすることは、エンジニアの効率を高めるだけでなく、より広範囲を網羅したテストを行うことにつながる傾向があります。  

## パブリックAPIに注目しても重要な動作は無視しない

パブリックAPI：一連のパブリック関数  

「パブリックAPIのみを使用してテストする」ということは、ユニットテストに関するごく一般的なアドバイスです。  
パブリックAPIに焦点を当てることで、実装の詳細よりも、このAPIの利用者が最終的に関心のある動作のみに集中せざるを得なくなります。これは、本当に重要なことを確実にテストするのに有益で、その過程でテストが実装の詳細にとらわれないように保ち続けるのに役立ちます。  

「パブリックAPIのみを使用してテストする」と「実装の詳細をテストしない」は、どちらも優れたアドバイスですが、あくまでも基本原則であり、「パブリックAPI」と「実装の詳細」の定義は、主観的かつコンテキスト固有のものである可能性を認める必要があります。最終的に重要なのは、コードのすべての重要な動作を適切にテストすることです。

## テストダブル

コードは他のものに依存する傾向があります。そうすると、コードのすべての動作を完全にテストするには、入力をセットアップして副作用を確認する必要があります。一方、プロダクションの依存関係をテストで使用することが、常に実行可能あるいは望ましいとは限りません。  

プロダクションの依存関係を使用する代わりに、**テストダブル** を使用できます。テストダブルは依存関係をシミュレートするオブジェクトですが、テストに適した手段です。

### テストダブルを使用する理由

テストダブルを使用するよくある理由は次の3つです。  

1: テストを簡単にする

一部の依存関係には、セットアップに多大な労力が必要なものもあります。依存関係それ自体に多くのパラメーターを指定する必要がある場合や、さらにセットアップが必要なサブ依存関係が多く存在することもあります。このような状況では、あらゆるものが手に負えなくなる可能性があります。テスト内にセットアップするコードの山ができ、テストコードが多くの実装の詳細と密接に結びついてしまうでしょう。  

対照的に、テストダブルを使用すると、プロダクションの依存関係をセットアップしたり、サブ依存関係ですべてを検証したりする必要がなくなります。

2: テストから外側の世界を守る

たとえば、支払いを処理するシステムがあるとします。顧客の銀行口座からお金を引き出すコードのユニットテストを行っていると想像してください。コードを現実の世界で実行すると、現実の顧客の口座からお金を引き落としてしまいます。このように、テストの副作用から外側の世界を守るために、独立してテストしなければならないのです。

3: テストを外側から守る

プロダクションの依存関係は、予測できない動作をすることがあります。この例としては、データベースから定期的に変化する値を読み取ったり、乱数ジェネレーターを使用してIDを生成したりするようなプロダクションの依存関係があります。テストでこのような依存関係を使用すると、テストがフレーキーになる可能性があり、これは避けたいものでしょう。

依存関係よりもテストダブルを使用したほうがよいと判断したら、次は使用するテストダブルの種類を決定する必要があります。最もよく使われるのは、モック、スタブ、フェイクの3つになります。  

#### モック

**モック** は、メンバ関数の呼び出しを記録する機能のみを提供し、クラスまたはインターフェイスをシミュレートします。  

以下のコードは、そのままテストすると依存関係により副作用が発生します：  
```
class PaymentManager {
    PaymentResult settleInvoice(BankAccount customerBankAccount, Invoice invoice) {
        customerBankAccount.debit(invoice.getBalance());
        return PaymentResult.paid(invoice.getId());
    }
}

interface BackAccount {
    void debit(MonetrayAmount amount);
    void credit(MonetaryAmount amount);
    MonetaryAmount getBalance();
}

class BankAccountImpl implements BankAccount {
    private final BankingBackend backend; // 現実の口座のお金に影響を与えるBankingBackendに依存する

    override void debit(MonetaryAmount amount) { ... }
    override void credit(MonetaryAmount amount) { ... }
    override MonetaryAmount getBalance() { ... }
}
```
現実の口座のお金に影響を与えるBankingBackendに依存しているため、顧客の実際の口座のお金が変わってしまいます。  

BankAccountImplを使用する代わりに、BackAccountインターフェイスのモックを作成してテストを行います。  
以下のコードは、モックを使用したテストの例です：  
```
void testSettleInvoice_accountDebited() {
    BankAccount mockAccount = createMock(BankAccount);  // BankAccountのモックを作成
    MonetaryAmount invoiceBalance = new MonetaryAmount(5.0, Currency.USD);
    Invoice invoice = new Invoice(invoiceBalance, "test-id");
    PaymentManager paymentManager = new PaymentManager();

    paymentManager.settleInvoice(mockAccount, invoice);

    // テストを実行
    // mockAccount.debit()が期待した引数で呼び出されたかをテストし、失敗したらアサート
    verifyThat(mockAccount.debit)
        .wasCalledOnce()
        .withArguments(invoiceBalance);
}
```

モックは  
- 主に外部への出力や振る舞いを検証するのに使用される
- 実態からかけ離れたテストに繋がる可能性がある

#### スタブ

**スタブ** は、関数を呼び出すたびに定義済みの値を返すことで、関数をシミュレートします。  
モックとスタブには明確な違いがありますが、多くのエンジニアはモックという言葉で両方を指していることが多いです。多くのテストツールでは、特定のメンバ関数をスタブするためだけに使用したい場合でも、モックと同様のツールを作成する必要があります。  

```
class PaymentManager {
 
    PaymentResult settleInvoice(BankAccount customerBankAccount, Invoice invoice) {

        if (customerBankAccount.getBalance().isLessThan(invoice.getBalance())) {
            return PaymentResult.insufficientFunds(invoice.getId());
        }

        customerBankAccount.debit(invoice.getBalance());
        return PaymentResult.paid(invoice.getId());
    }
}
```
モックの例で使用したsettleInvoice関数に新しい機能を追加しました。次のようなテストケースを追加し、以下に挙げたより多くの動作を確認する必要がでました。  

- 資金が不足している場合、「資金不足」のPaymentResultを返すこと
- 資金が不足している場合、口座から引き落とそうとしないこと
- 資金が足りている場合、口座から引き落とすこと

口座残高に依存するテストケースを作成しなければなりません。BankAccount.getBlance関数のスタブを作成し、この状況に対応します。  
```
void testSettleInvoice_insufficientFundsCorrectResultReturned() {
    MonetaryAmount invoiceBalance = new MonetaryAmount(10.0, Currency.USD);
    Invoice invoice = new Invoice(invoiceBalance, "test-id");

    BankAccount mockAccount = createMock(BankAccount);  // スタブを作成するためだけでもモックしている

    // getBalance関数はスタブ化され、常に9.99ドルを返すようにセットアップしている
    when(mockAccount.getBalance()).thenReturn(new MonetaryAmount(9.99, Currency.USD));

    PaymentManager paymentManager = new PaymentManager();
    PaymentResult result = paymentManager.settleInvoice(mockAccount, invoice);

    // テスト
    assertThat(result.getStatus()).isEqualTo(INSUFFICIENT_FUNDS);
}
```

スタブは  
- 主に内部に向かうコミュニケーションを模倣するのに使われる
- 実態からかけ離れたテストに繋がる可能性がある
- 単純な固定値の返却しかできないため、複雑な状態を持つテストには不向き

#### フェイク

**フェイク** は、テストで安全に使用できるクラス(またはインターフェイス)の代替実装です。  
プロダクションの依存関係のパブリックAPIを正確にシミュレートする必要がありますが、通常、その実装はプロダクションの依存関係よりも簡素化しています。多くの場合、外部システムと連携する代わりに、フェイク内のメンバ変数に状態を保存することで実現しています。  
依存しているコードの契約が変更された場合、フェイクのコードでの契約も更新しなければなりません。  

以下のコードは、BankAccountのフェイクの例です：  
```
class FakeBankAccount implements BankAccount {
    private MonetaryAmount balance;

    FakeBankAccount(MonetaryAmount startingBalance) {
        this.balance = startingBalance;
    }

    @Override
    void debit(MonetaryAmount amount) {
        if (amount.isNegative()) {
            throw new ArgumentException("金額はマイナスにできません");
        }
        balance = balance.subtract(amount);
    }

    @Override
    void credit(MonetaryAmount amount) {
        if (amount.isNegative()) {
            throw new ArgumentException("金額はマイナスにできません");
        }
        balance = balance.add(amount);
    }

    @Override
    void transfer(MonetaryAmount amount) {
        balance.add(amount);
    }

    @Override
    MonetaryAmount getBalance() {
        return roundDownToNearest10(balance);
    }

    MonetaryAmount getActualBalance() {
        return balance;
    }
}
```

### まとめ

- コードベースに送信されるほぼすべての「プロダクションコード」には、付随するユニットテストが必要である
- 「プロダクションコード」が示すすべての動作には、それを実行して結果をチェックするテストケースが付随するべきである。最も簡単なテストケース以外は、各テストケース内のコードを3つのセクション(Arrange, Act, Assert)に分割するのが一般的である
- 優れたユニットテストの主な特徴は、次のとおりである
  - 破損を正確に検出する
  - 実装の詳細にとらわれない
  - よく説明された失敗
  - わかりやすいテストコード
  - 簡単かつ迅速に実行できる
- テストダブルは、プロダクションの依存関係を使用することが不可能または実践的ではない場合に、ユニットテストで使用できる。テストダブルの例は次のとおりである
  - モック
  - スタブ
  - フェイク
- モックとスタブは実態からかけ離れていて、かつ実装の詳細と密接に結び付いたテストになる可能性がある
- モックとスタブの使用方法については、さまざまな考え方がある。筆者の意見としては、可能であればプロダクションの依存関係を使用するべきである。それができない場合はフェイクが次善の選択肢であり、モックとスタブは最後の手段としてのみ使用するべき

## ユニットテストの実践

### ただ関数をテストするのではなく動作をテストする

1関数につき1テストケースでは不十分である場合があります。すべての動作を網羅するようにテストケースを加えます。  
動作ではなく関数に焦点を合わせてテストを書いてはいけません。  

### テストのためだけに公開するのは避ける

プライベート関数は実装の詳細であり、コードの外側から認識されるべきではなく、直接利用されるべきではありません。プライベート関数を直接テストできるようにするため、プライベート関数をテストコードに公開したくなることがあります。しかし、これはよいアイデアではない場合が多く、結果として実装の詳細と密接にかかわったテストができあがり、本来関心を持つべきことを結局テストしていません。

クラス(やコード単位)がより複雑で多くのロジックを持ち始めた場合、パブリックAPI経由ですべての動作をテストするのは、少々難しくなっていきます。これは、抽象化レイヤーが厚くなりすぎたため、コードを小さい単位に分割した方がよいというサインです。

#### パラメタライズドテスト

**パラメタライズドテスト** は、引数を切り替えて同じテストを繰り返し実行するテストのことです。いくつかのテストフレームワークには、パラメタライズドテストを書くための機能があります。  

例：  

- C#のNUnitフレームワーク：TestCase属性  
- JavaのJUnitフレームワーク
- JavaScriptのJasmineフレームワーク

### 共通のテストのセットアップを適切に使う

多くのテストフレームワークでは、セットアップをテストケース間で簡単に共有できるようになっています。  

通常、共有されるセットアップのコードを設定できる実行タイミングは2つあります。  

- BeforeAll (もしくは OnTimeSetup)  
  BeforeAllブロックにあるセットアップのコードは、すべてのテストケースを実行する直前に1回だけ実行される
- BeforeEach (もしくは Setup)  
  BeforeEachブロックにあるセットアップのコードは、それぞれのテストケースを実行する直前に1回実行される

同じように、多くの場合、後処理のコードを実行する方法も提供しています。  

- AfterAll (もしくは OneTearDown)
- AfterEach (もしくは TearDown)

#### 状態の共有は問題になる可能性がある

あるテストケースが実行するアクションは、他のテストケースの結果に影響を与えるべきではありません。テストケース間で可変状態を共有すると、簡単にこのケースを誤って破ってしまいます。  

## 適切なアサーションマッチャーを使う

最新のテスト用のアサーションツールのほとんどは、テストで使用できる無数のマッチャーを持っています。

例：  

- Java：TruthライブラリーのcontainsAtLeast()
- JavaScript：JasmineフレームワークのJasmine.arrayContaining()

## DIを使っててスタビリティを補強する

ハードコーディングされた依存関係がテストを不可能にする例：
```
class InvoiceReminder {
    private final AddressBook addressBook;
    private final EmailSender emailSender;

    // コンストラクタ
    InvoiceReminder() {
        this.addressBook = DataStore.getAddressBook();  // DBからAddressBookを取得する
        this.emailSender = new EmailSenderImpl();   // 
    }

    @CheckReturnValue
    Boolean sendReminder(Invoice invoice) {
        EmailAddress? address = addressBook.lookupEmailAddress(invoice.getCustomerId());

        if (address == null) {
            return false;
        }

        // emailSenderを使用して実際にメールを送信
        return emailSender.send(address, InvoiceReminderTemplate.generate(invoice));
    }
}
```

- 顧客の情報が格納されたDBにアクセスしてしまう
- 顧客のアドレスにメールを送信してしまう

DIを利用した解決例：
```
class InvoiceReminder {
    private final AddressBook addressBook;
    private final EmailSender emailSender;

    // コンストラクタ経由でDI
    InvoiceReminder(
        AddressBook addressBook,
        EmailSender emailSender) {
        this.addressBook = addressBook;
        this.emailSender = emailSender;
    }

    static InvoiceReminder create() {
        return new InvoiceReminder(
            DataStore.getAddressBook(),
            new EmailSenderImpl());
    }

    @CheckReturnValue
    boolean sendReminder(Invoice invoice) {
        EmailAddress? address =
            addressBook.lookupEmailAddress(invoice.getCustomerId());
        if (address == null) {
            return false;
        }
        return emailSender.send(
            address,
            InvoiceReminderTemplate.generate(invoice));
    }
}
```
テストコードは以下のようになります：
```
FakeAddressBook addressBook = new FakeAddressBook();
addressBook.addEntry(
    customerId: 123456,
    emailAddress: "test@example.com");
FakeEmailSender emailSender = new FakeEmailSender();

InvoiceReminder invoiceReminder = 
    new InvoiceReminder(addressBook, emailSender);
```

## テストについての最後の言葉

ソフトウェアテストは膨大なトピックであり、この章で取り扱ったものは氷山の一角にすぎません。あなたがこれから遭遇する可能性が高いテストを示します。  

- インテグレーションテスト
- End-to-End(E2E)テスト
- リグレッションテスト
- ゴールデンテスト(仕様化テスト)
- ファズテスト

高水準のソフトウェアを書いてメンテナンスするには、多くの場合、それらを組み合わせて使用することが要求されます。ユニットテストだけですべてのテストのニーズを満たすことはおそらくないでしょう。さまざまな種類のテストに触れ、新しいツールやテクニックをキャッチアップしてくことが大事です。  

### まとめ

- 個々の関数に注目したテストは、容易に不十分なテストになる。すべての重要な動作を特定し、それぞれのテストを書くほうがもっと効果的である
- コードの最も重要な動作をテストすること。プライベート関数をテストすることは、ほとんどの場合において、最も重要なことをテストしていないことを示唆している
- 一度に1つのことだけをテストすることは、結果的にわかりやすいだけではなく、失敗の理由を明確に説明するテストになる
- セットアップの共有は諸刃の剣になる可能性が高い。コストの高いセットアップを繰り返すことを避けるが、もし適切に使っていないなら、ほとんどの場合で役に立たないフレーキーなテストにつながる
- DIの利用はコードのテスタビリティをかなり上げる
- ユニットテストはエンジニアが最も頻繁に扱う傾向がある段階のテストである。しかし、これだけがテストというわけではない。多くの場合、高水準のソフトウェアを書いてメンテナンスするには、複数の種類のテストのテクニックの使用が要求される

# null安全とオプショナル

**null安全** (または **void安全** ) がサポートされた言語を使っているなら活用しましょう。  
null安全がサポートされていない言語を使っているのであれば、nullの代替として **オプショナル型** を利用することをお勧めします。  

## null安全の使用

null安全の例：  
```
Element? getFifthElement(Int size) {    // Element? の「?」で、戻り値がnullになる可能性を明示している
  if (size < 5) {
    return null;
  }

  return new Element();
}
```
上記の関数を使用し、エラーとなるコードの例は次のようになります：  
```
void displayElement(Element element) {}   // 引数の型がnull非許容型

void displayFifthElement() {
  Element? fifthElement = getFifthElement(1);

  displayElement(fifthElement)  // null非許容型のため、この行でコンパイルエラー(もしくは静的解析でエラー)
}
```
上記の例では、fifthElementのnullチェックが必ず必要になります。  
値がnullになる可能性が明示されたことにより、コードの流れが推論されやすくなり、コードが読みやすく、nullが原因となるバグの可能性が低くなります。  

## オプショナルの使用

使用している言語がnull安全を提供していない場合、または何らかの理由で使用できない場合、オプショナル(Optional)のような型を代わりに使用して、戻り値が存在しない可能性を呼び出し元に認識させることができます。  

```
Optional<Element> getFifthElement(Int size) {
  if (size < 5) {
    return Optional.empty();  // nullの代わりにOptionalを使用
  }

  return new Element();
}
```
```
void displayFifthElement() {
  Optional<Element> fifthElement = getFifthElement(1);
  if (fifthElement.isPresent()) {         // オプショナル内に値が存在する確認
    displayElement(fifthElement.get());   // オプショナル内の値をget関数で取得
    return;
  }

  assert false, "要素は存在しません";      // エラー処理の例
}
```
シナリオ次第では、オプショナル型を使用すると、コードがやや冗長で不格好になることもあります。しかし、未処理のnullがあっという間にコード中に広まる可能性もあるため、この冗長性と不格好さの代償は、コードの堅牢性の向上とバグの減少という点で、たいてい十分に支払えます。  

# 訳者あとがき

## おさらい

- 高品質なコードは、信頼性が高く、保守が容易で、バグの少ないソフトウェアを生成すること、そして、コードが動き、動作し続け、要件の変更に対応しやすくすることが重要である
  - それを実現するための、6つのコード品質の柱がある
- 抽象化レイヤーという概念や、その中で出てくる関心の分離や凝集度、レイヤーの厚さ(薄さ)という考え方
- コードでの契約と、その中の紛れもなく明確な部分と不明瞭な部分について理解し、契約をどのように他のエンジニアに伝えるか
- 回復可能なエラーとそうでないもの、早い失敗と目立つ失敗、明示的または暗黙的なエラー通知のテクニック

## それらを実践する中で、気を付けるべきこと

- コードの名前、コメントの運用や行数の基準、コーディングスタイル、ネストや言語の機能(無名関数)
- マジックバリューとnullオブジェクトパターンの扱い方、予期せぬ挙動や引数の変更を取り除く、列挙型と網羅性
- 可変性と(深い)不変性、汎用的すぎるデータ型(や時間)の扱い、コードにおける唯一の情報源の意識
- DI(依存性注入)とインターフェイスの活用、デフォルトの戻り値の適切な利用、継承とis-a関係、カプセル化と実装の漏洩
- コードの想定を避ける、グローバル状態を避ける、関数の引数を必要なものに絞る、ジェネリクスの活用

## テストについて学んだこと

- よいユニットテストについて
- 「パブリックAPIに注目したテスト」という原則
- 1つのテストケースが網羅するべきなのは1つの動作
- モックやスタブ、フェイクといったテストダブルの用途と注意点
- 適切なアサーションマッチャーによる失敗の説明
- DIによるテスタビリティの確保

## 最後に

- 業務の中で「これは実践できそう」と気づいたところから、テクニックを試してみる
- 知識をアップデートするために、こういった書籍や議論に積極的に触れる
- 書籍やこういった議論の中には、すべての環境に100%当てはまるような絶対的なものはない

